# U3.W7: Designing Schemas


#### I worked on this challenge [by myself, with: ]


## Release 0: Student Roster Schema
![alt student_schema](week_7/imgs/student?schema.png "student schema")


## Release 1: One to Many Schema
![alt users orders](week_7/imgs/users_orders_release_1.png "users orders")


## Release 2: One to One Schema
![alt facebook one to one](week_7/imgs/one_to_one_facebook.png "facebook one to one")


## Release 3: Many to Many Schema
![alt join table](week_7/imgs/join_table.png "join table")


## Release 4: Design your own Schema
Description of what you're modeling: 

#For the one to one I am display a user field for an application called leaf, and the user id in an API it pulls from by John Deere
![alt add_column](week_7/imgs/4_release_3.png "nickname column")

#For the many to many I am display operators and fields. A field can be worked on by many operators and an operator can work on many farm fields.
<img src="week_7/imgs/many_to_many_custom.png"/>
![alt many_to_many](week_7/imgs/many_to_many_custom.png "many to many")

## Release 5: Reflection
# It was good to be able to read some of the formal sources used for this exercise. I had actually designed db schema for a MySQL db for a custom # application I am project managing right now-- all the way to identifying type, relationships like one-to many, and join tables. However I 
# learned a lot about the process of normalization.
#
# Looking at our businesses intranet, it has tremendously slow processing times despite the SQL Server being an all-star piece of hardware and way # overpowered for its needs. Reading about normalization makes me realize that the developers who were working on it did not apply those concepts # at all and we have tons of redundancys and errors caused by them. I sneakily think this is one of the mistakes behind the poor performance as 
# well.
#
#
#
#
#
