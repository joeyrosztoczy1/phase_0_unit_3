# U3.W7: Designing Schemas


#### I worked on this challenge [by myself, with: ]


## Release 0: Student Roster Schema
<img src="week_7/imgs/student_schema.png"/>


## Release 1: One to Many Schema
<img src="week_7/imgs/users_orders_release_1.png"/>


## Release 2: One to One Schema
<img src="week_7/imgs/one_to_one_facebook.png"/>


## Release 3: Many to Many Schema
<img src="week_7/imgs/join_table.png"/>


## Release 4: Design your own Schema
Description of what you're modeling: 

#For the one to one I am display a user field for an application called leaf, and the user id in an API it pulls from by John Deere
<img src="week_7/imgs/one_to_one_custom.png"/>

#For the many to many I am display operators and fields. A field can be worked on by many operators and an operator can work on many farm fields.
<img src="week_7/imgs/many_to_many_custom.png"/>

## Release 5: Reflection
# It was good to be able to read some of the formal sources used for this exercise. I had actually designed db schema for a MySQL db for a custom # application I am project managing right now-- all the way to identifying type, relationships like one-to many, and join tables. However I 
# learned a lot about the process of normalization.
#
# Looking at our businesses intranet, it has tremendously slow processing times despite the SQL Server being an all-star piece of hardware and way # overpowered for its needs. Reading about normalization makes me realize that the developers who were working on it did not apply those concepts # at all and we have tons of redundancys and errors caused by them. I sneakily think this is one of the mistakes behind the poor performance as 
# well.
#
#
#
#
#
